<!DOCTYPE html>
<html>
<head>
    <title>CHM Tiled Visualization - Open Forestry 4D</title>
    <style>
        :root {
            --panel-bg: rgba(33, 37, 41, 0.85);
            --panel-border: rgba(255, 255, 255, 0.1);
            --accent-color: #4CAF50;
            --text-color: #f8f9fa;
            --font-main: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
        }
        
        body { margin: 0; padding: 0; overflow: hidden; background-color: #303e4f;}
        canvas { display: block; }
        
        .visualization-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100vh;
            z-index: 10;
        }
        
        .info-panel {
            position: absolute;
            background: var(--panel-bg);
            color: var(--text-color);
            font-family: var(--font-main);
            font-size: 12px;
            line-height: 1.5;
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            padding: 12px 15px;
            backdrop-filter: blur(8px);
            border: 1px solid var(--panel-border);
            transition: opacity 0.3s ease;
            z-index: 100;
        }
    
        #info { bottom: 25px; left: 25px; min-width: 180px; }
        #colorLegend { bottom: 25px; right: 25px; display: flex; flex-direction: column; align-items: flex-start; }
        #errorMessage {
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(220, 53, 69, 0.9);
            max-width: 80%;
            text-align: center;
            display: none;
            padding: 15px 20px;
        }
        #loadingMessage {
            top: 40%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(33, 37, 41, 0.9);
            max-width: 80%;
            text-align: center;
            padding: 15px 20px;
        }
        #mapPanel {
            position: absolute;
            top: 10px;
            left: 20px;
            width: 300px;
            height: 160px;
            background: var(--panel-bg);
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            border: 1px solid var(--panel-border);
            z-index: 1000;
        }
        #map { width: 100%; height: 100%; }
        .leaflet-popup-content {
            font-size: 10px !important;
            line-height: 1.2 !important;
            margin: 5px !important;
            padding-right: 6px !important;
        }
        .leaflet-popup-content-wrapper {
            padding: 2px !important;
        }
        .leaflet-popup-tip-container {
            width: 10px !important;
            height: 10px !important;
        }
        
        .panel-title { 
            color: var(--accent-color); 
            font-weight: 600; 
            margin-bottom: 10px; 
            font-size: 14px; 
            text-transform: uppercase; 
            letter-spacing: 0.5px; 
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .panel-row { display: flex; margin-bottom: 6px; }
        .panel-label { opacity: 0.7; min-width: 80px; }
        .panel-value { font-weight: 500; }
        #gradientContainer { width: 200px; margin-top: 8px; }
        #gradientBar { width: 100%; height: 12px; border-radius: 6px; margin-bottom: 5px; }
        #gradientLabels { display: flex; justify-content: space-between; width: 100%; font-size: 11px; opacity: 0.8; }
        .control-button { 
            background: rgba(255, 255, 255, 0.1); 
            border: none; 
            color: var(--text-color); 
            padding: 5px 10px; 
            border-radius: 4px; 
            font-size: 12px; 
            cursor: pointer; 
            transition: background 0.2s; 
            margin-top: 10px; 
        }
        .control-button:hover { background: rgba(255, 255, 255, 0.2); }
        .control-button:disabled {
            background: rgba(255, 255, 255, 0.05);
            cursor: not-allowed;
            opacity: 0.5;
        }

    .dg.ac { 
        position: fixed !important; 
        top: 10px !important; 
        right: 12px !important; 
        left: auto !important; 
        z-index: 1000 !important; 
    }
    .dg.main {
        background: var(--panel-bg) !important;
        border: 1px solid var(--panel-border) !important;
        border-radius: 8px !important;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2) !important;
        backdrop-filter: blur(8px) !important;
        padding: 0 !important;
    }
    .dg .c { 
        color: var(--text-color) !important; 
    }
    .dg .cr { 
        border-left: none !important; 
    }
    .dg .property-name { 
        color: var(--text-color) !important; 
        font-family: var(--font-main) !important; 
        font-size: 12px !important; 
        opacity: 0.7 !important; 
    }
    .dg .c input[type="text"], .dg .c input[type="number"] { 
        background: rgba(255, 255, 255, 0.1) !important; 
        color: var(--text-color) !important; 
        border: none !important; 
        font-family: var(--font-main) !important; 
        font-size: 12px !important; 
    }
    .dg .c input[type="checkbox"] { 
        accent-color: var(--accent-color) !important; 
    }
    .dg .cr.function .property-name { 
        width: 100% !important; 
        color: var(--accent-color) !important; 
        opacity: 1 !important; 
    }
    .dg .cr.function:hover { 
        background: rgba(255, 255, 255, 0.1) !important; 
    }
    .dg .close-button { 
        position: relative !important;
        background: rgba(255, 255, 255, 0.1) !important; 
        border-top: none !important; 
        border-bottom-left-radius: 8px !important;
        border-bottom-right-radius: 8px !important;
        color: var(--text-color) !important; 
        font-family: var(--font-main) !important; 
        font-size: 12px !important; 
        text-align: center !important; 
        padding: 8px !important; 
        margin-top: 5px !important;
        width: 100% !important;
        box-sizing: border-box !important;
        display: flex !important;
        align-items: center !important;
        justify-content: center !important;
        min-height: 22px !important;
    }
    .dg .close-button:hover { 
        background: rgba(255, 255, 255, 0.2) !important; 
    }

        #heightDistributionModal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: var(--panel-bg);
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            border: 1px solid var(--panel-border);
            padding: 15px;
            z-index: 2000;
            display: none;
            width: 400px;
            max-width: 90%;
            max-height: 80vh;
            overflow: auto;
        }
        #heightDistributionChart {
            width: 100%;
            height: 200px !important;
        }
        .modal-content {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        @media (max-width: 768px) {
            #info, #colorLegend { max-width: 40%; font-size: 11px; }
            #gradientContainer { width: 150px; }
            #mapPanel { width: 200px; height: 150px; }
            .dg.ac { top: 170px !important; }
            #heightDistributionModal { width: 300px; }
            #heightDistributionChart { height: 150px; }
        }
    </style>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
</head>
<body>
    <div class="visualization-container">
        <div id="info" class="info-panel">
            <div class="panel-title">Canopy Height Model</div>
            <div class="panel-row">
                <div class="panel-label">Position:</div>
                <div class="panel-value" id="coordinates">-</div>
            </div>
            <div class="panel-row">
                <div class="panel-label">Height:</div>
                <div class="panel-value" id="heightValue">-</div>
            </div>
            <div class="panel-row">
                <div class="panel-label">Tile:</div>
                <div class="panel-value" id="tileName">-</div>
            </div>
            <div style="display: flex; gap: 10px;">
                <button class="control-button" id="showHeightDistribution">Show Height Distribution</button>
                <button class="control-button" id="downloadTile" disabled>Download Tile</button>
            </div>
        </div>
        
        <div id="colorLegend" class="info-panel">
            <div class="panel-title">Height (meters)</div>
            <div id="gradientContainer">
                <div id="gradientBar"></div>
                <div id="gradientLabels">
                    <span>0m</span>
                    <span id="maxHeightLabel">50m</span>
                </div>
            </div>
        </div>
        
        <div id="errorMessage" class="info-panel"></div>
        <div id="loadingMessage" class="info-panel">Loading CHM Data...</div>
        <div id="mapPanel">
            <div id="map"></div>
        </div>

        <div id="heightDistributionModal" class="info-panel">
            <div class="panel-title">
                <span>Height Distribution</span>
                <button class="control-button" id="closeHeightDistribution">Close</button>
            </div>
            <div class="modal-content">
                <canvas id="heightDistributionChart"></canvas>
            </div>
        </div>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/0.159.0/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/geotiff@2.0.7/dist-browser/geotiff.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.9/dat.gui.min.js"></script>
    <script src="OrbitControls.js"></script>
    <script src="tile_meta_data.js"></script>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.7.5/proj4.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>

    <script>
        let scene, camera, renderer, controls;
        let terrain, raycaster, mouse;
        let tiles = new Map();
        let maxHeight = 50;
        const tileSize = 1000;
        const visibleDistance = 3000;
        const loadingTiles = new Set(); // Track tiles being loaded
        let lastUpdateTime = 0; // For debouncing
        const updateInterval = 500; // Update every 500ms

        let tileRectangles = new Map();
        let selectedTileRectangle = null;
        let selectedTileKey = null;
        let heightDistributionChart;

        const colorStops = [
            { height: 0.0, color: new THREE.Color(0x003300) },
            { height: 0.2, color: new THREE.Color(0x339933) },
            { height: 0.4, color: new THREE.Color(0x66CC66) },
            { height: 0.6, color: new THREE.Color(0xFFCC00) },
            { height: 0.8, color: new THREE.Color(0xCC6600) },
            { height: 1.0, color: new THREE.Color(0xCC0000) }
        ];

        const settings = {
            heightScale: 1.0,
            wireframe: false,
            smoothShading: true,
            showControls: true,
            minHeightFilter: 0.0,
            updateTerrain: function() {
                tiles.forEach((tileData, key) => {
                    const tileMesh = terrain.getObjectByName(key);
                    if (tileMesh) {
                        terrain.remove(tileMesh);
                        disposeMesh(tileMesh);
                        createTileMesh(tileData, key);
                    }
                });
            },
            resetCamera: function() {
                const firstTile = tileMetadata[0];
                camera.position.set(firstTile.easting - tileMetadata[0].easting, 400, firstTile.northing - tileMetadata[0].northing + 600);
                controls.target.set(firstTile.easting - tileMetadata[0].easting, 0, firstTile.northing - tileMetadata[0].northing);
                controls.update();
                highlightTile(`${firstTile.easting}_${firstTile.northing}`);
                updateVisibleTiles();
            }
        };

        init();

        async function init() {
            setupScene();
            setupMap();
            setupHeightDistributionModal();
            document.getElementById('loadingMessage').style.display = 'block';
            
            const firstTile = tileMetadata[0];
            try {
                await loadTile(firstTile, true); // Show loading for initial tile
                createTileMesh(tiles.get(`${firstTile.easting}_${firstTile.northing}`), `${firstTile.easting}_${firstTile.northing}`);
                createColorLegend();
                document.getElementById('maxHeightLabel').textContent = `${maxHeight.toFixed(1)}m`;
                selectedTileKey = `${firstTile.easting}_${firstTile.northing}`;
                document.getElementById('loadingMessage').style.display = 'none';
                document.getElementById('downloadTile').disabled = false;
                highlightTile(selectedTileKey);
                animate();
            } catch (error) {
                showError(`Error loading initial tile: ${error.message}. Using dummy data.`);
                createDummyData();
                createTileMesh(tiles.get('dummy_0_0'), 'dummy_0_0');
                createColorLegend();
                selectedTileKey = 'dummy_0_0';
                document.getElementById('loadingMessage').style.display = 'none';
                document.getElementById('downloadTile').disabled = true;
                animate();
            }

            loadRemainingTiles();
            setupGUI();

            document.getElementById('downloadTile').addEventListener('click', downloadTile);
        }

        function showError(message) {
            const errorElement = document.getElementById('errorMessage');
            errorElement.textContent = message;
            errorElement.style.display = 'block';
            setTimeout(() => errorElement.style.display = 'none', 5000);
        }

        function showLoading(message) {
            const loadingElement = document.getElementById('loadingMessage');
            loadingElement.textContent = message;
            loadingElement.style.display = 'block';
        }

        function hideLoading() {
            const loadingElement = document.getElementById('loadingMessage');
            loadingElement.style.display = 'none';
        }

        function setupScene() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x2c3e50);
            
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 2000);
            camera.position.set(0, 400, 600);
            camera.lookAt(0, 0, 0);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.querySelector('.visualization-container').appendChild(renderer.domElement);
            
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.rotateSpeed = 0.7;
            
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();
            
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(500, 500, 500);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.near = 100;
            directionalLight.shadow.camera.far = 1500;
            directionalLight.shadow.camera.left = -500;
            directionalLight.shadow.camera.right = 500;
            directionalLight.shadow.camera.top = 500;
            directionalLight.shadow.camera.bottom = -500;
            scene.add(directionalLight);
            
            scene.fog = new THREE.FogExp2(0x2c3e50, 0.0007);
            
            terrain = new THREE.Group();
            scene.add(terrain);
            
            window.addEventListener('resize', onWindowResize);
            window.addEventListener('mousemove', onMouseMove);
        }

        function utmToLatLng(easting, northing) {
            const utmProj = '+proj=utm +zone=11 +datum=WGS84 +units=m +no_defs';
            const wgs84Proj = '+proj=longlat +datum=WGS84 +no_defs';
            
            const [lng, lat] = proj4(utmProj, wgs84Proj, [easting, northing]);
            
            return [lat, lng];
        }

        function highlightTile(tileKey) {
            tileRectangles.forEach((rectangle, key) => {
                if (key === tileKey) {
                    rectangle.setStyle({
                        color: '#FF4500',
                        weight: 1,
                        fillOpacity: 0.5
                    });
                    selectedTileRectangle = rectangle;
                    selectedTileKey = key;
                } else {
                    rectangle.setStyle({
                        color: '#4CAF50',
                        weight: 1,
                        fillOpacity: 0.2
                    });
                }
            });
        }

        function setupMap() {
            const map = L.map('map', {attributionControl: false}).setView([37.02, -119.20], 12);
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            }).addTo(map);

            tileMetadata.forEach(tile => {
                const [latSW, lngSW] = utmToLatLng(tile.easting, tile.northing);
                const [latNE, lngNE] = utmToLatLng(tile.easting + tileSize, tile.northing + tileSize);
                const bounds = [[latSW, lngSW], [latNE, lngNE]];
                
                const rectangle = L.rectangle(bounds, {
                    color: '#4CAF50',
                    weight: 1,
                    fillOpacity: 0.2
                }).addTo(map);
                
                const key = `${tile.easting}_${tile.northing}`;
                tileRectangles.set(key, rectangle);
                
                rectangle.on('click', async () => {
                    const heightDistributionModal = document.getElementById('heightDistributionModal');
                    if (heightDistributionModal) {
                        heightDistributionModal.style.display = 'none';
                    }
                    
                    const key = `${tile.easting}_${tile.northing}`;
                    
                    highlightTile(key);
                    
                    if (!tiles.has(key) && !loadingTiles.has(key)) {
                        showLoading(`Loading tile ${tile.file.split('/').pop()}...`);
                        loadingTiles.add(key);
                        try {
                            await loadTile(tile, true); // Show loading for selected tile
                            createTileMesh(tiles.get(key), key);
                            hideLoading();
                        } catch (error) {
                            hideLoading();
                            showError(`Failed to load tile ${tile.file.split('/').pop()}: ${error.message}`);
                        } finally {
                            loadingTiles.delete(key);
                        }
                    }

                    camera.position.set(
                        tile.easting - tileMetadata[0].easting,
                        400,
                        tile.northing - tileMetadata[0].northing + 600
                    );
                    controls.target.set(
                        tile.easting - tileMetadata[0].easting,
                        0,
                        tile.northing - tileMetadata[0].northing
                    );
                    controls.update();

                    if (!terrain.getObjectByName(key) && tiles.has(key)) {
                        createTileMesh(tiles.get(key), key);
                    }

                    selectedTileKey = key;
                    document.getElementById('downloadTile').disabled = false;
                    updateVisibleTiles();
                });
                
                rectangle.bindPopup(tile.file.split('/').pop());
            });

            const allBounds = tileMetadata.map(tile => {
                const [latSW, lngSW] = utmToLatLng(tile.easting, tile.northing);
                const [latNE, lngNE] = utmToLatLng(tile.easting + tileSize, tile.northing + tileSize);
                return [[latSW, lngSW], [latNE, lngNE]];
            });
            map.fitBounds(L.latLngBounds(allBounds.flat()));
        }

        async function loadTile(tile, showLoadingMessage = false) {
            const key = `${tile.easting}_${tile.northing}`;
            for (let attempt = 1; attempt <= 3; attempt++) {
                try {
                    const response = await fetch(tile.file);
                    if (!response.ok) throw new Error(`HTTP error! Status: ${response.status}`);
                    const arrayBuffer = await response.arrayBuffer();
                    const tiff = await GeoTIFF.fromArrayBuffer(arrayBuffer);
                    const image = await tiff.getImage();
                    
                    const width = image.getWidth();
                    const height = image.getHeight();
                    const rasters = await image.readRasters();
                    const heightData = rasters[0];
                    
                    let tileMaxHeight = 0;
                    let validDataCount = 0;
                    for (let i = 0; i < heightData.length; i++) {
                        if (heightData[i] !== -9999 && heightData[i] !== 65535 && heightData[i] >= 0) {
                            tileMaxHeight = Math.max(tileMaxHeight, heightData[i]);
                            validDataCount++;
                        } else {
                            heightData[i] = 0;
                        }
                    }
                    
                    if (validDataCount === 0) {
                        console.warn(`Tile ${tile.file} contains no valid height data.`);
                    }
                    
                    tiles.set(key, {
                        heightData,
                        width,
                        height,
                        maxHeight: tileMaxHeight,
                        easting: tile.easting,
                        northing: tile.northing,
                        file: tile.file
                    });
                    
                    maxHeight = Math.max(maxHeight, tileMaxHeight);
                    document.getElementById('maxHeightLabel').textContent = `${maxHeight.toFixed(1)}m`;
                    return;
                } catch (error) {
                    if (attempt === 3) {
                        throw new Error(`Failed to load tile ${key} after 3 attempts: ${error.message}`);
                    }
                    console.warn(`Attempt ${attempt} failed for ${tile.file}. Retrying...`);
                    await new Promise(resolve => setTimeout(resolve, 1000));
                }
            }
        }

        async function loadRemainingTiles() {
            const firstTile = tileMetadata[0];
            const centerPos = new THREE.Vector3(
                firstTile.easting - tileMetadata[0].easting,
                0,
                firstTile.northing - tileMetadata[0].northing
            );

            for (const tile of tileMetadata) {
                const key = `${tile.easting}_${tile.northing}`;
                if (key === `${firstTile.easting}_${firstTile.northing}`) continue;

                const tilePos = new THREE.Vector3(
                    tile.easting - tileMetadata[0].easting,
                    0,
                    tile.northing - tileMetadata[0].northing
                );
                const distance = centerPos.distanceTo(tilePos);

                if (distance < visibleDistance && !tiles.has(key) && !loadingTiles.has(key)) {
                    loadingTiles.add(key);
                    try {
                        await loadTile(tile, false); // Silent load for surrounding tiles
                        createTileMesh(tiles.get(key), key);
                    } catch (error) {
                        console.error(`Error loading ${tile.file}:`, error);
                        showError(`Failed to load tile ${tile.file.split('/').pop()}: ${error.message}`);
                    } finally {
                        loadingTiles.delete(key);
                    }
                }
            }
        }

        function createDummyData() {
            console.log("Creating dummy data for testing");
            const width = 100;
            const height = 100;
            const heightData = new Float32Array(width * height);
            
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const centerDist = Math.sqrt(
                        Math.pow((x - width/2) / (width/4), 2) + 
                        Math.pow((y - height/2) / (height/4), 2)
                    );
                    const noise = Math.sin(x * 0.5) * Math.cos(y * 0.5) * 5;
                    heightData[y * width + x] = Math.max(0, 40 * (1 - Math.min(1, centerDist))) + noise;
                }
            }
            
            tiles.set('dummy_0_0', {
                heightData,
                width,
                height,
                maxHeight: 45,
                easting: 0,
                northing: 0,
                file: 'dummy.tif'
            });
            maxHeight = 45;
        }

        function disposeMesh(mesh) {
            if (mesh.geometry) {
                mesh.geometry.dispose();
            }
            if (mesh.material) {
                if (Array.isArray(mesh.material)) {
                    mesh.material.forEach(mat => mat.dispose());
                } else {
                    mesh.material.dispose();
                }
            }
        }

        function createTileMesh(tileData, key) {
            const geometry = new THREE.PlaneGeometry(
                tileSize, tileSize,
                Math.min(tileData.width - 1, 199),
                Math.min(tileData.height - 1, 199)
            );
            
            const vertices = geometry.attributes.position.array;
            const halfWidth = tileSize / 2;
            const halfHeight = tileSize / 2;
            
            for (let i = 0; i < vertices.length; i += 3) {
                const x = Math.floor((vertices[i] + halfWidth) / tileSize * tileData.width);
                const y = Math.floor((vertices[i + 1] + halfHeight) / tileSize * tileData.height);
                const heightIndex = (tileData.height - y - 1) * tileData.width + x;
                let height = 0;
                
                if (heightIndex >= 0 && heightIndex < tileData.heightData.length) {
                    height = tileData.heightData[heightIndex];
                    if (height === 65535 || height < 0) height = 0;
                }
                
                height = (height >= settings.minHeightFilter) ? height * settings.heightScale : 0;
                vertices[i + 2] = height;
            }
            
            geometry.computeVertexNormals();
            applyVertexColors(geometry);
            
            const material = new THREE.MeshPhongMaterial({
                vertexColors: true,
                flatShading: !settings.smoothShading,
                wireframe: settings.wireframe,
                side: THREE.DoubleSide,
                shininess: 30
            });
            
            const tileMesh = new THREE.Mesh(geometry, material);
            tileMesh.rotation.x = -Math.PI / 2;
            tileMesh.position.set(
                tileData.easting - tileMetadata[0].easting,
                0,
                tileData.northing - tileMetadata[0].northing
            );
            tileMesh.receiveShadow = true;
            tileMesh.castShadow = true;
            tileMesh.name = key;
            tileMesh.userData = { key, file: tileData.file };
            
            terrain.add(tileMesh);
        }

        function applyVertexColors(geometry) {
            const positions = geometry.attributes.position.array;
            const colors = new Float32Array(positions.length);
            
            for (let i = 0; i < positions.length; i += 3) {
                const height = positions[i + 2] / (maxHeight * settings.heightScale);
                const color = getColorForHeight(height);
                
                colors[i] = color.r;
                colors[i + 1] = color.g;
                colors[i + 2] = color.b;
            }
            
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        }

        function getColorForHeight(normalizedHeight) {
            for (let i = 0; i < colorStops.length - 1; i++) {
                if (normalizedHeight >= colorStops[i].height && normalizedHeight <= colorStops[i + 1].height) {
                    const t = (normalizedHeight - colorStops[i].height) / (colorStops[i + 1].height - colorStops[i].height);
                    const color = new THREE.Color();
                    color.r = colorStops[i].color.r + t * (colorStops[i + 1].color.r - colorStops[i].color.r);
                    color.g = colorStops[i].color.g + t * (colorStops[i + 1].color.g - colorStops[i].color.g);
                    color.b = colorStops[i].color.b + t * (colorStops[i + 1].color.b - colorStops[i].color.b);
                    return color;
                }
            }
            return normalizedHeight <= 0 ? colorStops[0].color : colorStops[colorStops.length - 1].color;
        }

        function createColorLegend() {
            const gradientBar = document.getElementById('gradientBar');
            let gradientCSS = 'linear-gradient(to right';
            colorStops.forEach(stop => {
                const hexColor = '#' + stop.color.getHexString();
                gradientCSS += `, ${hexColor} ${stop.height * 100}%`;
            });
            gradientCSS += ')';
            gradientBar.style.background = gradientCSS;
            gradientBar.style.boxShadow = '0 2px 4px rgba(0,0,0,0.2)';
            gradientBar.style.borderRadius = '4px';
        }

        function unloadFarTiles() {
            const cameraPos = camera.position;
            const unloadDistance = visibleDistance * 2;
            const tilesToRemove = [];

            tiles.forEach((tileData, key) => {
                const tilePos = new THREE.Vector3(
                    tileData.easting - tileMetadata[0].easting,
                    0,
                    tileData.northing - tileMetadata[0].northing
                );
                const distance = cameraPos.distanceTo(tilePos);

                if (distance >= unloadDistance && key !== selectedTileKey) {
                    tilesToRemove.push(key);
                }
            });

            tilesToRemove.forEach(key => {
                const tileMesh = terrain.getObjectByName(key);
                if (tileMesh) {
                    terrain.remove(tileMesh);
                    disposeMesh(tileMesh);
                }
                tiles.delete(key);
            });
        }

        async function updateVisibleTiles() {
            const now = Date.now();
            if (now - lastUpdateTime < updateInterval) return;
            lastUpdateTime = now;

            const cameraPos = camera.position;
            let loadingCount = 0;

            // Identify tiles to load (limit concurrent loads)
            for (const tile of tileMetadata) {
                if (loadingCount >= 3) break;
                const key = `${tile.easting}_${tile.northing}`;
                if (tiles.has(key) || loadingTiles.has(key)) continue;

                const tilePos = new THREE.Vector3(
                    tile.easting - tileMetadata[0].easting,
                    0,
                    tile.northing - tileMetadata[0].northing
                );
                const distance = cameraPos.distanceTo(tilePos);

                if (distance < visibleDistance) {
                    loadingTiles.add(key);
                    loadingCount++;
                    const isSelectedTile = key === selectedTileKey;
                    if (isSelectedTile) {
                        showLoading(`Loading tile ${tile.file.split('/').pop()}...`);
                    }
                    try {
                        await loadTile(tile, isSelectedTile);
                        createTileMesh(tiles.get(key), key);
                    } catch (error) {
                        showError(`Failed to load tile ${tile.file.split('/').pop()}: ${error.message}`);
                    } finally {
                        loadingTiles.delete(key);
                        if (isSelectedTile) {
                            hideLoading();
                        }
                    }
                }
            }

            // Update visibility of loaded tiles
            tiles.forEach((tileData, key) => {
                const tilePos = new THREE.Vector3(
                    tileData.easting - tileMetadata[0].easting,
                    0,
                    tileData.northing - tileMetadata[0].northing
                );
                const distance = cameraPos.distanceTo(tilePos);

                if (distance < visibleDistance && !terrain.getObjectByName(key)) {
                    createTileMesh(tileData, key);
                } else if (distance >= visibleDistance && terrain.getObjectByName(key) && key !== selectedTileKey) {
                    const tileMesh = terrain.getObjectByName(key);
                    terrain.remove(tileMesh);
                    disposeMesh(tileMesh);
                }
            });

            // Unload far-away tiles
            unloadFarTiles();
        }

        function setupGUI() {
            const gui = new dat.GUI({ autoPlace: true, width: 310 });
            gui.domElement.style.opacity = '0.9';
            
            const terrainFolder = gui.addFolder('Forest Settings');
            terrainFolder.add(settings, 'heightScale', 0.1, 5.0).name('Height Exaggeration').onChange(settings.updateTerrain);
            terrainFolder.add(settings, 'wireframe').name('Wireframe').onChange(value => {
                terrain.children.forEach(child => {
                    child.material.wireframe = value;
                    child.material.needsUpdate = true;
                });
            });
            terrainFolder.add(settings, 'smoothShading').name('Smooth Shading').onChange(value => {
                terrain.children.forEach(child => {
                    child.material.flatShading = !value;
                    child.material.needsUpdate = true;
                });
            });
            terrainFolder.add(settings, 'minHeightFilter', 0, maxHeight, 0.1).name('Min Height Filter (m)').onChange(settings.updateTerrain);
            
            const cameraFolder = gui.addFolder('Camera');
            cameraFolder.add(settings, 'resetCamera').name('Reset Camera Position');
            
            terrainFolder.open();
            
            window.addEventListener('keydown', (event) => {
                if (event.key === 'h' || event.key === 'H') {
                    settings.showControls = !settings.showControls;
                    gui.domElement.style.display = settings.showControls ? '' : 'none';
                    document.getElementById('mapPanel').style.display = settings.showControls ? '' : 'none';
                }
            });
        }

        function setupHeightDistributionModal() {
            const ctx = document.getElementById('heightDistributionChart').getContext('2d');
            heightDistributionChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'Height Distribution',
                        data: [],
                        backgroundColor: 'rgba(76, 175, 80, 0.7)',
                        borderColor: 'rgba(76, 175, 80, 1)',
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false },
                        title: { display: false }
                    },
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: 'Height (m)',
                                color: 'rgba(255, 255, 255, 0.7)',
                                font: { size: 12 }
                            },
                            ticks: { color: 'rgba(255, 255, 255, 0.7)', font: { size: 10 } }
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Frequency',
                                color: 'rgba(255, 255, 255, 0.7)',
                                font: { size: 12 }
                            },
                            ticks: { color: 'rgba(255, 255, 255, 0.7)', font: { size: 10 } },
                            beginAtZero: true
                        }
                    }
                }
            });

            const modal = document.getElementById('heightDistributionModal');
            const showButton = document.getElementById('showHeightDistribution');
            const closeButton = document.getElementById('closeHeightDistribution');

            showButton.addEventListener('click', () => {
                if (selectedTileKey && tiles.has(selectedTileKey)) {
                    updateHeightDistribution(selectedTileKey);
                    modal.style.display = 'block';
                } else {
                    showError('No tile selected. Please hover over a tile or click on the map.');
                }
            });

            closeButton.addEventListener('click', () => {
                modal.style.display = 'none';
            });
        }

        function updateHeightDistribution(tileKey) {
            if (!tiles.has(tileKey)) return;

            const tileData = tiles.get(tileKey);
            const heights = [];
            for (let i = 0; i < tileData.heightData.length; i++) {
                const height = tileData.heightData[i];
                if (height > 0 && height !== 65535) {
                    heights.push(height);
                }
            }

            if (heights.length === 0) {
                heightDistributionChart.data.labels = [];
                heightDistributionChart.data.datasets[0].data = [];
                heightDistributionChart.update();
                return;
            }

            const numBins = 20;
            const tileMaxHeight = tileData.maxHeight || Math.max(...heights);
            const binWidth = tileMaxHeight / numBins;
            const bins = Array(numBins).fill(0);
            const labels = Array(numBins).fill(0).map((_, i) => (i * binWidth).toFixed(1));

            heights.forEach(height => {
                const binIndex = Math.min(Math.floor(height / binWidth), numBins - 1);
                bins[binIndex]++;
            });

            heightDistributionChart.data.labels = labels;
            heightDistributionChart.data.datasets[0].data = bins;
            heightDistributionChart.update();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function onMouseMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(terrain.children);
            
            if (intersects.length > 0) {
                const point = intersects[0].point;
                const tileMesh = intersects[0].object;
                selectedTileKey = tileMesh.userData.key;

                const actualEasting = point.x + tileMetadata[0].easting;
                const actualNorthing = point.z + tileMetadata[0].northing;
        
                const utmProj = '+proj=utm +zone=11 +datum=WGS84 +units=m +no_defs';
                const wgs84Proj = '+proj=longlat +datum=WGS84 +no_defs';
                const [longitude, latitude] = proj4(utmProj, wgs84Proj, [actualEasting, actualNorthing]);
        
                document.getElementById('coordinates').textContent = 
                    `Lat: ${latitude.toFixed(7)}, Lng: ${longitude.toFixed(7)}`;
                document.getElementById('heightValue').textContent = `${point.y.toFixed(1)}m`;
                document.getElementById('tileName').textContent = tileMesh.userData.file.split('/').pop();
                document.getElementById('downloadTile').disabled = tileMesh.userData.key.includes('dummy');
            } else {
                document.getElementById('coordinates').textContent = '-';
                document.getElementById('heightValue').textContent = '-';
                document.getElementById('tileName').textContent = '-';
                document.getElementById('downloadTile').disabled = true;
            }
        }

        function downloadTile() {
            if (!selectedTileKey || !tiles.has(selectedTileKey)) {
                showError('No tile selected for download.');
                return;
            }

            const tileData = tiles.get(selectedTileKey);
            const fileName = tileData.file.split('/').pop();

            try {
                const newTab = window.open(tileData.file, '_blank');
                if (!newTab) {
                    throw new Error('Failed to open new tab. Please allow popups for this site.');
                }
            } catch (error) {
                showError(`Failed to initiate download: ${error.message}`);
            }
        }
       
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            updateVisibleTiles();
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
